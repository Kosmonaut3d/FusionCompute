#version 440 core

layout(local_size_x = 4, local_size_y = 4, local_size_z = 4) in;

layout(rgba32f, binding = 0) uniform readonly image2D pcl_input;
layout(rgba32f, binding = 1) uniform readonly image2D pcl_normal_input;
layout(rg32f, binding = 2) uniform image3D model_output;

uniform float _stepSize;
uniform mat4x4 _modelMatrix;
uniform mat4x4 _pclWorldToClip;
uniform mat4x4 _viewToWorld;
uniform mat3x3 _viewToWorldRot;
uniform float _truncationDistance;
uniform float _maxWeight = 20;

const float W2 = 320;
const float H2 = 240;

#define FLT_MAX 10000

vec2 worldToDistance(vec3 worldPos)
{  
	// NOTE: transform from world to camera -> project
	vec4 clipSpacePos = _pclWorldToClip * vec4(worldPos, 1);

	vec2 outputValueWeight = vec2(FLT_MAX, 0.000000001);

	if (clipSpacePos.w == 0 || clipSpacePos.z == 0)
	{
		return outputValueWeight;
	}

	vec3 ndc = vec3(clipSpacePos) / clipSpacePos.w;
	if (abs(ndc.x) >= 1 || abs(ndc.y) >= 1)
	{
		return outputValueWeight;
	}

	// OPENGL
	ndc.y      = -ndc.y;
	int x_proj = int( round((ndc.x + 1) * W2));
	int y_proj = int(round((ndc.y + 1) * H2));
		
	// STILL VIEWSPACE
	vec3 pclPos = imageLoad(pcl_input, ivec2(x_proj, y_proj)).xyz;

	if(pclPos.z >= 0)
	{
		return outputValueWeight;
	}

	vec3 pclWorldPos = vec4(_viewToWorld * vec4(pclPos, 1)).xyz;
	vec3 dist = worldPos - pclWorldPos;
	float len = length(dist);

	if(abs(len) < _truncationDistance)
	{
		vec3 pclNor = _viewToWorldRot * imageLoad(pcl_normal_input, ivec2(x_proj, y_proj)).xyz;
		float dotProduct = dot(normalize(dist), normalize(pclNor));
		float scaledLen = len * FLT_MAX /_truncationDistance;
		return vec2(sign(dotProduct)*scaledLen, 1);
	}

	// We are not close enough, but our pixel is legit - weight = 1
	return vec2(FLT_MAX, 1);
}

void main() {
	// base pixel colour for image
	ivec3 pixel_coords = ivec3(gl_GlobalInvocationID.xyz);

	vec3 worldVoxelPosition = (_modelMatrix * vec4((pixel_coords + vec3(0.5, 0.5, 0.5))*_stepSize, 1)).xyz;

	vec2 valueWeigth = worldToDistance(worldVoxelPosition);

	if(valueWeigth.y > 0)
	{
		vec2 previousData = imageLoad(model_output, pixel_coords).rg;

		float accValue = (previousData.y * previousData.x + valueWeigth.x * valueWeigth.y) / (valueWeigth.y + previousData.y);
		float accWeight = min(valueWeigth.y + previousData.y, _maxWeight);

		imageStore(model_output, pixel_coords, vec4(accValue, accWeight, 0,0));
	}
  // NOTE: Nvidia could use derivatives for normal maps;

  // Problem: openGL reads textures from bottom
}
