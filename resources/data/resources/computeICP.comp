#version 440

layout(local_size_x = 1, local_size_y = 1) in;

layout(rgba32f, binding = 0) uniform readonly coherent image2D vertex_old;
layout(rgba32f, binding = 1) uniform readonly coherent image2D vertex_new;
layout(rgba32f, binding = 2) uniform writeonly coherent image2D correspondence;

layout(binding = 0, offset=0) uniform atomic_uint correspondence_counter;

uniform mat3x3 viewToWorldItRot;
uniform mat4x4 viewToWorldIt; // View To World

uniform mat4x4 viewToWorldOld; // View To World previous

uniform mat4x4 viewProjectionIt; // Current iteration view projection

const float WIDTH2 = 320; //halfed
const float HEIGHT2 = 240;

void main() {
	// base pixel colour for image
	ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);

	vec3 vertexNewWorld = (viewToWorldIt * vec4(imageLoad(vertex_new, pixel_coords).xyz, 1)).xyz;
	if(vertexNewWorld.z == 0)
	{
		return;
	}

	vec4 vertexNewClip = viewProjectionIt * vec4(vertexNewWorld, 1);
	if(vertexNewClip.w == 0)
	{
		return;
	}

	vec3 vertexNdc = vertexNewClip.xyz / vertexNewClip.w;
	if(clamp(vertexNdc, -1.f, 1.f) != vertexNdc)
	{
		return;
	}

	// Note: Flip y (OPENGL)
	ivec2 pixel_coord_projected = ivec2(round((vertexNdc.x + 1.0f) * WIDTH2), round((-vertexNdc.y+1.0f) * HEIGHT2));

	vec3 vertexOldWorld = (viewToWorldOld * vec4(imageLoad(vertex_old, pixel_coord_projected).xyz, 1)).xyz;

	vec3 diff = vertexOldWorld-vertexNewWorld;

	uint currentCount = atomicCounterIncrement(correspondence_counter);
    //memoryBarrier();
	
	imageStore(correspondence, pixel_coords, vec4(diff, 1));
}
